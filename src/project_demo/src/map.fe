use ingot::evm

// BUFFER

trait Buffer {
    fn write_word(mut self, offset: u256, _ w: u256)
    fn read_word(mut self, offset: u256) -> u256
}

// MEMORY BUFFER

pub struct MemBuffer { ptr: evm::Ptr, len: u256 }

impl Buffer for MemBuffer {
    fn write_word(mut self, offset: u256, _ w: u256) {
        evm::__mstore(self.ptr.location.upcast() + offset, w)
    }
    fn read_word(mut self, offset: u256) -> u256 {
        evm::__mload(self.ptr.location.upcast() + offset)
    }
}

// STORAGE BUFFER

pub struct StorageBuffer {}

impl Buffer for StorageBuffer {
    fn write_word(mut self, offset: u256, _ w: u256) {
        evm::__sstore(offset, w)
    }
    fn read_word(mut self, offset: u256) -> u256 {
        evm::__sload(offset)
    }
}

// CURSOR

// Question: should B be a generic or a Buffer?
pub struct Cursor<B: Buffer> {
    inner: B,
    pos: u256
}

// CURSOR

impl<B: Buffer> Write for Cursor<B> {
    fn write_word(mut self, _ w: u256) {
        // Question: should we check bounds here instead of in the Buffer trait?
        //if self.pos > self.inner.len {
        //    evm::__revert()
        //}
        self.inner.write_word(offset: self.pos, w)
        self.pos += 32
    }
}

impl<B: Buffer> Read for Cursor<B> {
    fn read_word(mut self) -> u256 {
        // Question: should we check bounds here instead of in the Buffer trait?
        //if self.pos > self.inner.len {
        //    evm::__revert()
        //}
        let word: u256 = self.inner.read_word(offset: self.pos)
        self.pos += 32
        return word
    }
}

// WRITE

trait Write {
    fn write_word(mut self, _ w: u256)
}

impl Write for MemBuffer {
    fn write_word(mut self, _ w: u256) {
        // Question: should we check bounds here instead of in the Buffer trait?
        if self.ptr.location.upcast() > self.len {
            evm::__revert()
        }
        Buffer::write_word(self, offset: self.ptr.location.upcast(), w) 
    }
}

impl Write for StorageBuffer {
    fn write_word(mut self, _ w: u256) {
        Buffer::write_word(self, offset: 0, w)
    }
}

trait Read {
    fn read_word(mut self) -> u256
}

impl Read for MemBuffer {
    fn read_word(mut self) -> u256 {
        // Question: should we check bounds here instead of in the Buffer trait?
        if self.ptr.location.upcast() > self.len {
            evm::__revert()
        }
        Buffer::read_word(self, offset: 0)
    }
}

impl Read for StorageBuffer {
    fn read_word(mut self) -> u256 {
        Buffer::read_word(self, offset: 0)
    }
}


// ENCODE AND DECODE

pub trait Decode {
    fn decode<R: Read>(mut r: R) -> Self
    fn decode_size() -> usize
}

pub trait Encode {
    fn encode<W: Write>(self, mut _ w: W)
    fn encode_size() -> usize
}

impl Decode for u256 {
    fn decode<R: Read>(mut r: R) -> u256 {
        r.read_word()
    }
    fn decode_size() -> usize {
        32
    }
}

impl Encode for u256 {
    fn encode<W: Write>(self, mut _ w: W) {
        w.write_word(self)
    }
    fn encode_size() -> usize {
        32
    }
}

struct Map<T, U> {
    // Question: should this be u8 or u256?
    slot: u8,
}

impl<T, U> Map<T, U>
    where T: Encode, U: Encode, U: Decode
{
    pub fn get(self, key: T) -> U {
        let allocated_buffer = evm::alloc(len: T::encode_size() + evm::SLOT_SIZE)
        let mut key_cursor = Cursor { 
            inner: MemBuffer { 
                ptr: allocated_buffer.offset,
                len: allocated_buffer.len.upcast()
            },
            pos: 0
        }

        key.encode(key_cursor)
        self.slot.upcast().encode(key_cursor)

        let value_slot : u256 = evm::__keccak256(args: allocated_buffer)
        
        let value_cursor = Cursor {
            inner: StorageBuffer {},
            pos: value_slot
        }
        U::decode(r: value_cursor)
    }

    pub fn set(self, _ key: T, _ value: U) {
        let allocated_buffer = evm::alloc(len: T::encode_size() + evm::SLOT_SIZE)
        let mut key_cursor = Cursor { 
            inner: MemBuffer { 
                ptr: allocated_buffer.offset,
                len: allocated_buffer.len.upcast()
            },
            pos: 0
        }

        key.encode(key_cursor)
        self.slot.upcast().encode(key_cursor)

        let value_slot : u256 = evm::__keccak256(args: allocated_buffer)
        let value_cursor = Cursor {
            inner: StorageBuffer {},
            pos: value_slot
        }
        value.encode(value_cursor)
    }
}